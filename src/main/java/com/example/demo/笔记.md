# 2022.04.24 
+ 目前这个笔记的主要任务就是积累信息
## 关于Json
+ Spring中 内置了Jackson ，可以直接使用ObjectMapper对象，无需在pom.xml中引入依赖,只要用 @Autowired 要引入bean对象
    将对象转换为json字符串
    objectMapper.writeValueAsString(student);
    将字符串转换为对象
    objectMapper.readValue(jsonString, Student.class);

## 关于注解
+ 使用@RequestMapper 包含了对所有方法的请求路径，如不加@ResponseBody注解，则返回页面信息；加了@ResponseBody 返回自定义类型数据。
+ @RestController = @ResponseBody + @Controller
+ @PathVariable : 动态的从URL中获取变量作为参数。
+ @RequestPart : 上传文件
+ @Configuration : [标志了@Configuratio的类，就是配置系统的]
                   @Configuration 用于定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被@Bean注解的方法
                   这些方法将会被[AnnotationConfigApplicationContext] 或 [AnnotationConfigWebApplicationContext]类进行扫描，并用于构建bean定义，初始化Spring容器。
                   在程序启动之前是先进行配置类的加载的。
## 关于Lombok
+ @Data -> 实现getter setter方法
+ @Getter -> 实现getter方法
+ @Setter -> 实现setter方法
+ @ToString -> 实现toString方法

## 关于日志
+ @slf4j -> 可以直接使用log.info  log.xx 进行日志操作

## Jquery
$.ajax({
    url:"",             //发送文件文件地址
    type:"post",        //发送方式post/get ……，也可以用method指定请求方式
    headers: { 'Accept':' */*' },       //按需求填，一般不用写
    async:false,        //同步
    contentType: 'application/json',    // 发送json 时添加，否则发送的是formdata
    dataType:'json',    // 发送json 时添加，否则发送的是formdata
    data:{              //发送的数据，如果发json -> data:JSON.stringify(json)；
        "name":key,     //name自己定，key事先获取
    },   
    success:function(data){             //成功执行方法
        if(data==0){
            window.location.href='/';   //页面重定向
        }
    }
})

## 拦截器
+ 实现过程，以登录拦截器为例:
    1. 实现HandlerInterceptor接口
    2. 重写preHandle方法
    3. 方法中进行需要进行的逻辑校验
    4. 最后在SpringMVC配置中，将该拦截器添加相应的拦截规则(即在@Configuration修饰的类中，重写addInterceptors方法，在方法中添加拦截规则)

## 关于配置类(@Configuration) 有必要单独拿出来说一说
+ Spring使用BeanDefinitionRegistry注册中心管理着所有的Bean定义信息，那么对于这些Bean信息哪些属于@Configuration配置呢，这是需要甄选出来的。
+ 判断一个Bean是否是@Configuration配置类这个逻辑统一交由ConfigurationClassUtils这个工具类去完成。
+ [ConfigurationClassUtils工具类] 
        见名之意，它是和配置有关的一个工具类，提供几个静态工具方法供以使用。
        它是Spring 3.1新增，对于它的作用，官方给的解释是：用于标识@Configuration类的实用程序(Utilities)。
        它主要提供了一个方法：checkConfigurationClassCandidate()用于检查给定的Bean定义是否是配置类的候选对象（或者在配置/组件类中声明的嵌套组件类），并做相应的标记。
+ [checkConfigurationClassCandidate()]    
        它是一个public static工具方法，用于判断某个Bean定义是否是@Configuration配置。
        @Configuration配置类肯定是个组件，存在于IoC容器里;
        @Configuration配置类是有主次之分的，主配置类是驱动整个程序的入口，可以是一个，也可以是多个（若存在多个，支持使用@Order排序）;
        我们平时一般只书写次配置类（而且一般写多个），它一般是借助主配置类的@ComponentScan能力完成加载进而解析的（当然也可能是@Import、又或是被其它次配置类驱动的）;
        配置类可以存在嵌套（如内部类），继承，实现接口等特性聊完了最为重要的checkConfigurationClassCandidate()方法，当然还有必要看看ConfigurationClassUtils的另一个工具方法isConfigurationCandidate();
+ [isConfigurationCandidate()] 
        它是一个public static工具方法，通过给定的注解元数据信息来判断它是否是一个Configuration。
        若是接口类型（含注解类型），直接不予考虑，返回false。否则继续判断
        若此类上标注有@Component、@ComponentScan、@Import、@ImportResource任意一个注解，就判断成功返回true。否则继续判断
        到此步，就说明此类上没有标注任何注解。若存在@Bean方法，返回true，否则返回false。
        需要特别特别特别注意的是：此方法它的并不考虑@Configuration注解，是“轻量级”判断，这是它和checkConfigurationClassCandidate()方法的最主要区别。当然，后者依赖于前者，依赖它来根据注解元数据判断是否是Lite模式的配置。